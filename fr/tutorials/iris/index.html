<!doctype html><html lang=fr class="js csstransforms3d"><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.58.3"><meta name=description content="Gorgonia's reference website"><meta name=author content="The Gorgonia Authors"><link rel="shortcut icon" href=/images/favicon.png type=image/png><title>Régression linéaire multivariée sur le dataset Iris :: Gorgonia</title><link href=/css/nucleus.css?1572884042 rel=stylesheet><link href=/css/fontawesome-all.min.css?1572884042 rel=stylesheet><link href=/css/hybrid.css?1572884042 rel=stylesheet><link href=/css/featherlight.min.css?1572884042 rel=stylesheet><link href=/css/perfect-scrollbar.min.css?1572884042 rel=stylesheet><link href=/css/auto-complete.css?1572884042 rel=stylesheet><link href=/css/atom-one-dark-reasonable.css?1572884042 rel=stylesheet><link href=/css/theme.css?1572884042 rel=stylesheet><link href=/css/hugo-theme.css?1572884042 rel=stylesheet><link href=/css/theme-gorgonia.css?1572884042 rel=stylesheet><script src=/js/jquery-3.3.1.min.js?1572884042></script><style>:root #header+#content>#left>#rlblock_left{display:none!important}</style><script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script><meta property=og:title content="Régression linéaire multivariée sur le dataset Iris"><meta property=og:description content="A propos Nous allons utiliser Gorgonia pour créer un modèle de régression linéaire.
Le but de ce tutoriel est de prédire l&rsquo;espèce d&rsquo;une fleur en fonction de ses caractéristiques:
 sepal_length // longueur du sépale sepal_width // largeur du sépale petal_length // longueur du pétale petal_width // largeurdu pétale  Les espèces que nous voulons prédire sont:
 setosa virginica versicolor  Le but de ce tutoriel est de programmer Gorgonia pour qu&rsquo;il trouve seul les paramètres qui permettent de déterminer la relation entre les attributs et le spécimen."><meta property=og:type content=article><meta property=og:url content=https://gorgonia.org/fr/tutorials/iris/><meta property=og:image content=https://gorgonia.org/images/opengraph.png><meta property=article:published_time content=2019-10-31T14:53:37+01:00><meta property=article:modified_time content=2019-10-31T14:53:37+01:00><meta property=og:site_name content=Gorgonia><meta name=twitter:card content=summary_large_image><meta name=twitter:image content=https://gorgonia.org/images/opengraph.png><meta name=twitter:title content="Régression linéaire multivariée sur le dataset Iris"><meta name=twitter:description content="A propos Nous allons utiliser Gorgonia pour créer un modèle de régression linéaire.
Le but de ce tutoriel est de prédire l&rsquo;espèce d&rsquo;une fleur en fonction de ses caractéristiques:
 sepal_length // longueur du sépale sepal_width // largeur du sépale petal_length // longueur du pétale petal_width // largeurdu pétale  Les espèces que nous voulons prédire sont:
 setosa virginica versicolor  Le but de ce tutoriel est de programmer Gorgonia pour qu&rsquo;il trouve seul les paramètres qui permettent de déterminer la relation entre les attributs et le spécimen."></head><body data-url=/fr/tutorials/iris/><nav id=sidebar class=showVisitedLinks><div id=header-wrapper><div id=header><a id=logo href=https://gorgonia.org/><img src=https://gorgonia.org/images/logo/gorgonia.svg></a></div><div class=searchbox><label for=search-by><i class="fas fa-search"></i></label><input data-search-input id=search-by type=search placeholder=Rechercher...>
<span data-search-clear><i class="fas fa-times"></i></span></div><script type=text/javascript src=/js/lunr.min.js?1572884042></script><script type=text/javascript src=/js/auto-complete.js?1572884042></script><script type=text/javascript>var baseurl="https:\/\/gorgonia.org\/\/fr";</script><script type=text/javascript src=/js/search.js?1572884042></script></div><div class=highlightable><ul class=topics><li data-nav-id=/fr/getting-started/ title="Premiers pas" class=dd-item><a href=/fr/getting-started/><b>X. </b>Premiers pas
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/fr/about/ title="Fonctionnement de Gorgonia" class=dd-item><a href=/fr/about/><b>X. </b>Fonctionnement de Gorgonia
<i class="fas fa-check read-icon"></i></a></li><li data-nav-id=/fr/tutorials/ title=Tutoriels class="dd-item
        parent"><a href=/fr/tutorials/><b>X. </b>Tutoriels
<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/fr/tutorials/iris/ title="Régression linéaire multivariée sur le dataset Iris" class="dd-item active"><a href=/fr/tutorials/iris/>Régression linéaire multivariée sur le dataset Iris
<i class="fas fa-check read-icon"></i></a></li></ul></li><li data-nav-id=/fr/how-to/ title=How-tos class=dd-item><a href=/fr/how-to/>How-tos
<i class="fas fa-check read-icon"></i></a><ul><li data-nav-id=/fr/how-to/dataframe/ title="Créer un tensor depuis un Dataframe (gota)" class=dd-item><a href=/fr/how-to/dataframe/>Créer un tensor depuis un Dataframe (gota)
<i class="fas fa-check read-icon"></i></a></li></ul></li></ul><section id=shortcuts><h3>Aller plus loin</h3><ul><li><a class=padding href=https://github.com/gorgonia/gorgonia><i class="fab fa-fw fa-github"></i>Repo GitHub</a></li><li><a class=padding href=https://godoc.org/gorgonia.org/gorgonia><i class="fas fa-fw fa-bookmark"></i>Godoc</a></li></ul></section><section id=prefooter><hr><ul><li><a class=padding><i class="fas fa-language fa-fw"></i><div class=select-style><select id=select-language onchange="location=this.value;">
<option id=en value=https://gorgonia.org/tutorials/iris/>English</option>
<option id=fr value=https://gorgonia.org/fr/tutorials/iris/ selected>Français</option>
<option id=jp value=https://gorgonia.org/jp/tutorials/iris/>Japanese</option></select><svg id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="255" height="255" viewBox="0 0 255 255" style="enable-background:new 0 0 255 255"><g><g id="arrow-drop-down"><path d="M0 63.75l127.5 127.5L255 63.75z" /></g></g></svg></div></a></li><li><a class=padding href=# data-clear-history-toggle><i class="fas fa-history fa-fw"></i>Supprimer l&#39;historique</a></li></ul></section><section id=footer><center><a class=github-button href=https://github.com/gorgonia/gorgonia data-icon=octicon-star data-show-count=true aria-label="Star gorgonia/gorgonia on GitHub">Star</a><p>Built with <a href=https://github.com/matcornic/hugo-theme-learn><i class="fas fa-heart"></i></a>from <a href=https://getgrav.org>Grav</a> and <a href=https://gohugo.io/>Hugo</a></p></center><script async defer src=https://buttons.github.io/buttons.js></script></section></div></nav><section id=body><div id=overlay></div><div class="padding highlightable"><div><div id=top-bar><div id=top-github-link><a class=github-link title="Modifier la page" href=https://github.com/gorgonia/gorgonia.github.io/edit/develop/content/tutorials/iris.fr.md target=blank><i class="fas fa-code-branch"></i><span id=top-github-link-text>Modifier la page</span></a></div><div id=breadcrumbs itemscope itemtype=http://data-vocabulary.org/Breadcrumb><span id=sidebar-toggle-span><a href=# id=sidebar-toggle data-sidebar-toggle><i class="fas fa-bars"></i></a></span><span id=toc-menu><i class="fas fa-list-alt"></i></span><span class=links><a href=/fr/>Gorgonia</a> > <a href=/fr/tutorials/>Tutoriels</a> > Régression linéaire multivariée sur le dataset Iris</span></div><div class=progress><div class=wrapper><nav id=TableOfContents><ul><li><ul><li><a href=#a-propos>A propos</a><ul><li><a href=#représentation-mathématique>Représentation Mathématique</a></li><li><a href=#régression-linéaire>Régression linéaire</a></li></ul></li><li><a href=#génération-des-données-d-entrainement-avec-gota-dataframe>Génération des données d&rsquo;entrainement avec gota (dataframe)</a><ul><li><a href=#creation-de-l-exprgrap>Creation de l&rsquo;ExprGrap</a></li></ul></li><li><a href=#préparation-du-calcul-du-gradient>Préparation du calcul du gradient</a><ul><li><a href=#creation-du-node-qui-contiendra-le-coût-de-l-équation>Creation du &ldquo;node&rdquo; qui contiendra le coût de l&rsquo;équation</a></li><li><a href=#la-descente-du-gradient>La descente du gradient</a><ul><li><a href=#l-apprentissage>L&rsquo;apprentissage</a></li><li><a href=#afficer-des-informations>Afficer des informations</a></li></ul></li><li><a href=#sauvegarde-des-données>Sauvegarde des données</a></li></ul></li><li><a href=#création-d-un-utilitaire-cli>Création d&rsquo;un utilitaire CLI</a></li></ul></li><li><a href=#conclusion>Conclusion</a><ul><li><ul><li><a href=#bonus-visual-representation>Bonus: visual representation</a></li></ul></li></ul></li></ul></nav></div></div></div></div><div id=head-tags></div><div id=body-inner><h1>Régression linéaire multivariée sur le dataset Iris</h1><h2 id=a-propos>A propos</h2><p>Nous allons utiliser Gorgonia pour créer un modèle de régression linéaire.</p><p>Le but de ce tutoriel est de prédire l&rsquo;espèce d&rsquo;une fleur en fonction de ses caractéristiques:</p><ul><li>sepal_length // longueur du sépale</li><li>sepal_width // largeur du sépale</li><li>petal_length // longueur du pétale</li><li>petal_width // largeurdu pétale</li></ul><p>Les espèces que nous voulons prédire sont:</p><ul><li>setosa</li><li>virginica</li><li>versicolor</li></ul><p>Le but de ce tutoriel est de programmer Gorgonia pour qu&rsquo;il trouve seul les paramètres qui permettent de déterminer la relation entre les attributs
et le spécimen.
À la fin, nous écrirons un utilitaire CLI (autonome) dont l&rsquo;interface sera la suivante:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>./iris
sepal length: 5
sepal width: 3.5
petal length: 1.4
sepal length: 0.2

It is probably a setosa</code></pre></div><div class="notices warning"><p>Ce tutoriel est à vocation académique. Son but est de décrire comment réaliser une régression linéaire
multivariée avec Gorgonia; Ainsi, le modèle utilisé n&rsquo;est pas la meilleur réponse à ce problème particulier.</p></div><h3 id=représentation-mathématique>Représentation Mathématique</h3><p>Nous considérons que l&rsquo;espèce d&rsquo;une Iris est fonction de la longueur et de la largeur de son sépale ainsi que de la longueur et de la largeur de son pétale.</p><p>Par conséquent, soit $y$ une valeur représentant l&rsquo;espèce, l&rsquo;équation que nous essayons de résoudre est:</p><p>$$ y = \theta_0 + \theta_1 * sepal\_length + \theta_2 * sepal\_width + \theta_3 * petal\_length + \theta_4 * petal\_width$$</p><p>Considérons à présent les vecteurs $x$ et $\Theta$ suivants:</p><p>$$ x = \begin{bmatrix} sepal\_length &amp; sepal\_width &amp; petal\_length &amp; petal\_width &amp; 1\end{bmatrix}$$</p><p>$$
\Theta = \begin{bmatrix}
\theta_4<br>\theta_3<br>\theta_2<br>\theta_1<br>\theta_0<br>\end{bmatrix}
$$</p><p>Nous pouvons réécrire l&rsquo;équation:</p><p>$$y = x\cdot\Theta$$</p><h3 id=régression-linéaire>Régression linéaire</h3><p>Pour trouver les bonnes valeurs de $\Theta$ rendant l&rsquo;équation vraie pour la majorité des Iris, nous allons utiliser une régression linéaire.</p><p>Nous allons encoder les données d&rsquo;entrainement (les constats fait sur plusieurs fleurs) dans une matrice $X$.
$X$ est composée de 5 colonnes: sepal length, sepal width, petal length, petal width et une colonne contenant 1 pour le biais.
Chaque ligne de la matrice représente une fleur.</p><p>Nous allons encoder les espèces dans un vecteur colonne $Y$ composé de nombres flottants.</p><ul><li>setosa = 1.0</li><li>virginica = 2.0</li><li>versicolor = 3.0</li></ul><p>Lors de la phase d&rsquo;apprentissage, le coût est exprimé de la manière suivante:</p><p>$cost = \dfrac{1}{m} \sum_{i=1}^m(X^{(i)}\cdot\Theta-Y^{(i)})^2$</p><p>Nous allons utiliser la méthode de descente de gradient pour optimiser le coût et obtenir les valeurs optimales de $\Theta$.</p><div class="notices info"><p>Il est possible d&rsquo;avoir les valeurs exactes de $\Theta$ (celle qui minimisent le coût) en utilisant l&rsquo;équation normale:
$$ \theta = \left( X^TX \right)^{-1}X^TY $$
Vous trouverez sur ce <a href=https://gist.github.com/owulveryck/19a5ba9553ff8209b3b4227b5325041b#file-normal-go>gist</a>
une implémentation basique de la solution réalisée avec Gonum.</p></div><h2 id=génération-des-données-d-entrainement-avec-gota-dataframe>Génération des données d&rsquo;entrainement avec gota (dataframe)</h2><p>Tout d&rsquo;abord, générons les données d&rsquo;entrainement. Nous utiliserons un dataframe pour nous simplifier la tâche.</p><div class="notices info"><p>Ce <a href=/how-to/dataframe/>howto</a> donne plus d&rsquo;information sur l&rsquo;utilisation du dataframe</p></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getXYMat</span>() (<span style=color:#f92672>*</span><span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>Dense</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>Dense</span>) {
        <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;iris.csv&#34;</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
        }
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
        <span style=color:#a6e22e>df</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dataframe</span>.<span style=color:#a6e22e>ReadCSV</span>(<span style=color:#a6e22e>f</span>)
        <span style=color:#a6e22e>xDF</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>df</span>.<span style=color:#a6e22e>Drop</span>(<span style=color:#e6db74>&#34;species&#34;</span>)

        <span style=color:#a6e22e>toValue</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>series</span>.<span style=color:#a6e22e>Series</span>) <span style=color:#a6e22e>series</span>.<span style=color:#a6e22e>Series</span> {
                <span style=color:#a6e22e>records</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Records</span>()
                <span style=color:#a6e22e>floats</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>float64</span>, len(<span style=color:#a6e22e>records</span>))
                <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>records</span> {
                        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>r</span> {
                        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;setosa&#34;</span>:
                                <span style=color:#a6e22e>floats</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>1</span>
                        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;virginica&#34;</span>:
                                <span style=color:#a6e22e>floats</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>2</span>
                        <span style=color:#66d9ef>case</span> <span style=color:#e6db74>&#34;versicolor&#34;</span>:
                                <span style=color:#a6e22e>floats</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>3</span>
                        <span style=color:#66d9ef>default</span>:
                                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;unknown iris: %v\n&#34;</span>, <span style=color:#a6e22e>r</span>)
                        }
                }
                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>series</span>.<span style=color:#a6e22e>Floats</span>(<span style=color:#a6e22e>floats</span>)
        }

        <span style=color:#a6e22e>yDF</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>df</span>.<span style=color:#a6e22e>Select</span>(<span style=color:#e6db74>&#34;species&#34;</span>).<span style=color:#a6e22e>Capply</span>(<span style=color:#a6e22e>toValue</span>)
        <span style=color:#a6e22e>numRows</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>xDF</span>.<span style=color:#a6e22e>Dims</span>()
        <span style=color:#a6e22e>xDF</span> = <span style=color:#a6e22e>xDF</span>.<span style=color:#a6e22e>Mutate</span>(<span style=color:#a6e22e>series</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>one</span>(<span style=color:#a6e22e>numRows</span>), <span style=color:#a6e22e>series</span>.<span style=color:#a6e22e>Float</span>, <span style=color:#e6db74>&#34;bias&#34;</span>))
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>xDF</span>.<span style=color:#a6e22e>Describe</span>())
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>yDF</span>.<span style=color:#a6e22e>Describe</span>())

        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>DenseCopyOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>matrix</span>{<span style=color:#a6e22e>xDF</span>}), <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>DenseCopyOf</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>matrix</span>{<span style=color:#a6e22e>yDF</span>})
}</code></pre></div><p>Cette fonction retourne deux matrices que nous pourrons utiliser avec Gorgonia.</p><h3 id=creation-de-l-exprgrap>Creation de l&rsquo;ExprGrap</h3><p>L&rsquo;équation $X\cdot\Theta$ est encodée en tant qu&rsquo;<a href=/reference/exprgraph>ExprGraph</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getXY</span>() (<span style=color:#f92672>*</span><span style=color:#a6e22e>tensor</span>.<span style=color:#a6e22e>Dense</span>, <span style=color:#f92672>*</span><span style=color:#a6e22e>tensor</span>.<span style=color:#a6e22e>Dense</span>) {
	<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getXYMat</span>()

	<span style=color:#a6e22e>xT</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tensor</span>.<span style=color:#a6e22e>FromMat64</span>(<span style=color:#a6e22e>x</span>)
	<span style=color:#a6e22e>yT</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tensor</span>.<span style=color:#a6e22e>FromMat64</span>(<span style=color:#a6e22e>y</span>)
	<span style=color:#75715e>// Get rid of the last dimension to create a vector
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>yT</span>.<span style=color:#a6e22e>Shape</span>()
	<span style=color:#a6e22e>yT</span>.<span style=color:#a6e22e>Reshape</span>(<span style=color:#a6e22e>s</span>[<span style=color:#ae81ff>0</span>])
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xT</span>, <span style=color:#a6e22e>yT</span>
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>xT</span>, <span style=color:#a6e22e>yT</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getXY</span>()
	<span style=color:#a6e22e>g</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NewGraph</span>()
	<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NodeFromAny</span>(<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>xT</span>, <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithName</span>(<span style=color:#e6db74>&#34;x&#34;</span>))
	<span style=color:#a6e22e>y</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NodeFromAny</span>(<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>yT</span>, <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithName</span>(<span style=color:#e6db74>&#34;y&#34;</span>))
	<span style=color:#a6e22e>theta</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NewVector</span>(
		<span style=color:#a6e22e>g</span>,
		<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Float64</span>,
		<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithName</span>(<span style=color:#e6db74>&#34;theta&#34;</span>),
		<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithShape</span>(<span style=color:#a6e22e>xT</span>.<span style=color:#a6e22e>Shape</span>()[<span style=color:#ae81ff>1</span>]),
		<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithInit</span>(<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Uniform</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>)))

	<span style=color:#a6e22e>pred</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>must</span>(<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Mul</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>theta</span>))
    <span style=color:#75715e>// Saving the value for later use
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>predicted</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Value</span>
    <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Read</span>(<span style=color:#a6e22e>pred</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>predicted</span>)</code></pre></div><div class="notices warning"><p>Gorgonia est très optimisé; il fait utilise beaucoup les pointeurs pour optimiser son empreinte mémoire.
Par conséquemt, appeler la méthode <code>Value()</code> d&rsquo;un <code>*Node</code> pendant la phase d&rsquo;exécution du graphe, peut produire des résultats incorrects.
Pour accéder à la valeur contenue dans un <code>*Node</code> (pendant la phase d&rsquo;apprentissage par exemple), il est nécessaire de garder une référence
pointant sur ladite valeur. C&rsquo;est la raison pour laquelle nous utilisons la méthode <code>Read</code>.
<code>predicted</code> contient une référence à la valeur résultante de l&rsquo;opération $X\cdot\Theta$.</p></div><h2 id=préparation-du-calcul-du-gradient>Préparation du calcul du gradient</h2><p>Nous allons utiliser la fonctionnalité de Gorgonia: <a href=/how-to/differentiation>Symbolic differentiation</a>.</p><p>Tout d&rsquo;abord, nous allons créer une fonction de coût, puis utiliser un <a href=/about/solver>solver</a> pour faire la descente de gradient.</p><h3 id=creation-du-node-qui-contiendra-le-coût-de-l-équation>Creation du &ldquo;node&rdquo; qui contiendra le coût de l&rsquo;équation</h3><p>Completons à présent l&rsquo;<a href=/reference/exprgraph>exprgraph</a> en ajoutant le coût (pour rappel, $cost = \dfrac{1}{m} \sum_{i=1}^m(X^{(i)}\cdot\Theta-Y^{(i)})^2$)</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>squaredError</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>must</span>(<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Square</span>(<span style=color:#a6e22e>must</span>(<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#a6e22e>pred</span>, <span style=color:#a6e22e>y</span>))))
<span style=color:#a6e22e>cost</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>must</span>(<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Mean</span>(<span style=color:#a6e22e>squaredError</span>))</code></pre></div><p>Notre but est de minimiser ce coût. Nous allons donc calculer le gradient de la fonction par rapport à $\Theta$:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Grad</span>(<span style=color:#a6e22e>cost</span>, <span style=color:#a6e22e>theta</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatalf</span>(<span style=color:#e6db74>&#34;Failed to backpropagate: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
}</code></pre></div><h3 id=la-descente-du-gradient>La descente du gradient</h3><p>Nous utilisons le principe de descente de gradient. Ceci signifie que nous utilisons le gradient de la fonction pour
altérer le paramètre $\Theta$ pas à pas.</p><p>Une implémentation basique de descente de gradient est implémentée dans le <a href=https://godoc.org/gorgonia.org/gorgonia#VanillaSolver>Vanilla Solver</a> de Gorgonia.
Nous positionnons le &ldquo;pas&rdquo; $\gamma$ à 0.001.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>solver</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NewVanillaSolver</span>(<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithLearnRate</span>(<span style=color:#ae81ff>0.001</span>))</code></pre></div><p>À chaque étape, nous allons demander au solver de mettre à jour $\Theta$ grâce au gradient.
Par conséquent, nous assignons une variable <code>update</code> que nous allons passer au solver à chaque itération.</p><div class="notices info"><p>La descente de gradient va mettre à jour toutes les valeurs présentes dans le tableau <code>[]gorgonia.ValueGrad</code> à chqaue étape
suivant cette équation:
${\displaystyle x^{(k+1)}=x^{(k)}-\gamma \nabla f\left(x^{(k)}\right)}$
Il est important de comprendre que le solver travaille sur des <a href=/reference/value><code>Values</code></a> et non des <a href=/reference/node><code>Nodes</code></a>.
Cependant, afin de simplifier les choses, l&rsquo;interface <code>ValueGrad</code> est implémenté par la structure <code>*Node</code>.</p></div><p>Dans notre cas, nous voulons trouver les valeurs de $\Theta$; nous demandons au solver de mettre à jour la valeur en suivant cette équation:</p><p>${\displaystyle \Theta^{(k+1)}=\Theta^{(k)}-\gamma \nabla f\left(\Theta^{(k)}\right)}$</p><p>Le solver se charge d&rsquo;implémenter l&rsquo;équation. Nous devons simplement passer $\Theta$ a chaque <code>Step</code> du <code>Solver</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>update</span> <span style=color:#f92672>:=</span> []<span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>ValueGrad</span>{<span style=color:#a6e22e>theta</span>}
<span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>solver</span>.<span style=color:#a6e22e>Step</span>(<span style=color:#a6e22e>update</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
}</code></pre></div><h4 id=l-apprentissage>L&rsquo;apprentissage</h4><p>À présent que la mécanique est en place, nous devons lancer le calcul grâce à une <a href=/referemce/vm>vm</a>.
Ce calcul doit être lancé un grand nombre de fois pour que la descente de gradient puisse agir.</p><p>Créons à présent une <a href=/reference/vm>vm</a> pour lancer le calcul.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>machine</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NewTapeMachine</span>(<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>BindDualValues</span>(<span style=color:#a6e22e>theta</span>))
<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>machine</span>.<span style=color:#a6e22e>Close</span>()</code></pre></div><div class="notices warning"><p>Nous demandons au solver de mettre à jour le paramètre $\Theta$ par rapport au gradient.
Par conséquent nous devons dire à la TapeMachine de stocker la valeur de $\Theta$ <em>ainsi que</em> sa dérivée (sa dual value)
Ceci est la raison de l&rsquo;utilisation de la fonction <a href=https://godoc.org/gorgonia.org/gorgonia#BindDualValues>BindDualValues</a>.</p></div><p>Maintenant nous pouvons créer une boucle et calculer le graphe étape par étape; la machine va apprendre!</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>iter</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1000000</span>
<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>iter</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>machine</span>.<span style=color:#a6e22e>RunAll</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Error during iteration: %v: %v\n&#34;</span>, <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>err</span>)
                <span style=color:#66d9ef>break</span>
        }

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>solver</span>.<span style=color:#a6e22e>Step</span>(<span style=color:#a6e22e>model</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
        }
        <span style=color:#a6e22e>machine</span>.<span style=color:#a6e22e>Reset</span>() <span style=color:#75715e>// Reset is necessary in a loop like this
</span><span style=color:#75715e></span>}</code></pre></div><h4 id=afficer-des-informations>Afficer des informations</h4><p>Nous pouvons afficher des informations sur le processus d&rsquo;apprentissage en utilisant cet appel:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;theta: %2.2f  Iter: %v Cost: %2.3f Accuracy: %2.2f \r&#34;</span>,
        <span style=color:#a6e22e>theta</span>.<span style=color:#a6e22e>Value</span>(),
        <span style=color:#a6e22e>i</span>,
        <span style=color:#a6e22e>cost</span>.<span style=color:#a6e22e>Value</span>(),
        <span style=color:#a6e22e>accuracy</span>(<span style=color:#a6e22e>predicted</span>.<span style=color:#a6e22e>Data</span>().([]<span style=color:#66d9ef>float64</span>), <span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>Value</span>().<span style=color:#a6e22e>Data</span>().([]<span style=color:#66d9ef>float64</span>)))</code></pre></div><p>Avec la fonction <code>accuracy</code> définie de la manière suivante:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>accuracy</span>(<span style=color:#a6e22e>prediction</span>, <span style=color:#a6e22e>y</span> []<span style=color:#66d9ef>float64</span>) <span style=color:#66d9ef>float64</span> {
        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ok</span> <span style=color:#66d9ef>float64</span>
        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>prediction</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
                <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Round</span>(<span style=color:#a6e22e>prediction</span>[<span style=color:#a6e22e>i</span>]<span style=color:#f92672>-</span><span style=color:#a6e22e>y</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
                        <span style=color:#a6e22e>ok</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1.0</span>
                }
        }
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ok</span> <span style=color:#f92672>/</span> float64(len(<span style=color:#a6e22e>y</span>))
}</code></pre></div><p>Ceci affichera une ligne semblable à celle ci pendant la phase d&rsquo;apprentissage:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>theta: [ 0.26  -0.41   0.44  -0.62   0.83]  Iter: 26075 Cost: 0.339 Accuracy: 0.61</code></pre></div><h3 id=sauvegarde-des-données>Sauvegarde des données</h3><p>Une fois l&rsquo;entrainement terminé, nous pouvons sauvegarder les valeurs de $\Theta$ pour pouvoir les utiliser dans des prédictions:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>value</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>error</span> {
	<span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Create</span>(<span style=color:#e6db74>&#34;theta.bin&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
	<span style=color:#a6e22e>enc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gob</span>.<span style=color:#a6e22e>NewEncoder</span>(<span style=color:#a6e22e>f</span>)
	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>enc</span>.<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>value</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
	}
	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
}</code></pre></div><h2 id=création-d-un-utilitaire-cli>Création d&rsquo;un utilitaire CLI</h2><p>Nous allons à présent créer un utilitaire qui va permettre de donner l&rsquo;espèce d&rsquo;une fleur en fonction des paramètres d&rsquo;entrée.</p><p>Tout d&rsquo;abord, chargeons les paramètres que nous venons de sauvegarder lors de la phase d&rsquo;entrainement.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
        <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;theta.bin&#34;</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
        }
        <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Close</span>()
        <span style=color:#a6e22e>dec</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gob</span>.<span style=color:#a6e22e>NewDecoder</span>(<span style=color:#a6e22e>f</span>)
        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>thetaT</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>tensor</span>.<span style=color:#a6e22e>Dense</span>
        <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>dec</span>.<span style=color:#a6e22e>Decode</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>thetaT</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
        }</code></pre></div><p>Ensuite, créeons le modèle (l&rsquo;exprgraph) d&rsquo;une manière semblable à ce que nous avons fait auparavant:</p><div class="notices info"><p>Dans un développement logiciel, il serait probablement souhaitable de partager ce code entre les deux outils (training et execution) en l&rsquo;isolant dans un package.</p></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>g</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NewGraph</span>()
<span style=color:#a6e22e>theta</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NodeFromAny</span>(<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>thetaT</span>, <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithName</span>(<span style=color:#e6db74>&#34;theta&#34;</span>))
<span style=color:#a6e22e>values</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>float64</span>, <span style=color:#ae81ff>5</span>)
<span style=color:#a6e22e>xT</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tensor</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>tensor</span>.<span style=color:#a6e22e>WithBacking</span>(<span style=color:#a6e22e>values</span>))
<span style=color:#a6e22e>x</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NodeFromAny</span>(<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>xT</span>, <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>WithName</span>(<span style=color:#e6db74>&#34;x&#34;</span>))
<span style=color:#a6e22e>y</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>Mul</span>(<span style=color:#a6e22e>x</span>, <span style=color:#a6e22e>theta</span>)</code></pre></div><p>Ensuite nous executons une boucle infinie pendant laquelle nous allons demander les infos, calculer et afficher le résultat:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>machine</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gorgonia</span>.<span style=color:#a6e22e>NewTapeMachine</span>(<span style=color:#a6e22e>g</span>)
<span style=color:#a6e22e>values</span>[<span style=color:#ae81ff>4</span>] = <span style=color:#ae81ff>1.0</span>
<span style=color:#66d9ef>for</span> {
        <span style=color:#a6e22e>values</span>[<span style=color:#ae81ff>0</span>] = <span style=color:#a6e22e>getInput</span>(<span style=color:#e6db74>&#34;sepal length&#34;</span>)
        <span style=color:#a6e22e>values</span>[<span style=color:#ae81ff>1</span>] = <span style=color:#a6e22e>getInput</span>(<span style=color:#e6db74>&#34;sepal widt&#34;</span>)
        <span style=color:#a6e22e>values</span>[<span style=color:#ae81ff>2</span>] = <span style=color:#a6e22e>getInput</span>(<span style=color:#e6db74>&#34;petal length&#34;</span>)
        <span style=color:#a6e22e>values</span>[<span style=color:#ae81ff>3</span>] = <span style=color:#a6e22e>getInput</span>(<span style=color:#e6db74>&#34;petal width&#34;</span>)

        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>machine</span>.<span style=color:#a6e22e>RunAll</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
        }
        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>math</span>.<span style=color:#a6e22e>Round</span>(<span style=color:#a6e22e>y</span>.<span style=color:#a6e22e>Value</span>().<span style=color:#a6e22e>Data</span>().(<span style=color:#66d9ef>float64</span>)) {
        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;It is probably a setosa&#34;</span>)
        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span>:
                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;It is probably a virginica&#34;</span>)
        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span>:
                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;It is probably a versicolor&#34;</span>)
        <span style=color:#66d9ef>default</span>:
                <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;unknown iris&#34;</span>)
        }
        <span style=color:#a6e22e>machine</span>.<span style=color:#a6e22e>Reset</span>()
}</code></pre></div><p>Voici une fonction utilitaire pour récupérer les entrées:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>getInput</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>float64</span> {
        <span style=color:#a6e22e>reader</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewReader</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stdin</span>)
        <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%v: &#34;</span>, <span style=color:#a6e22e>s</span>)
        <span style=color:#a6e22e>text</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reader</span>.<span style=color:#a6e22e>ReadString</span>(<span style=color:#e6db74>&#39;\n&#39;</span>)
        <span style=color:#a6e22e>text</span> = <span style=color:#a6e22e>strings</span>.<span style=color:#a6e22e>Replace</span>(<span style=color:#a6e22e>text</span>, <span style=color:#e6db74>&#34;\n&#34;</span>, <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)

        <span style=color:#a6e22e>input</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>ParseFloat</span>(<span style=color:#a6e22e>text</span>, <span style=color:#ae81ff>64</span>)
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
                <span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
        }
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span>
}</code></pre></div><p>Il ne reste plus qu&rsquo;à &ldquo;builder&rdquo; le code et voilà!
Nous avons un utilitaire autonome capable de prédire l&rsquo;espèce d&rsquo;une Irir en fonction de ses attributs:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>$ go run main.go
sepal length: 4.4
sepal widt: 2.9
petal length: 1.4
petal width: 0.2
It is probably a setosa
sepal length: 5.9
sepal widt: 3.0
petal length: 5.1
petal width: 1.8
It is probably a virginica</code></pre></div><h1 id=conclusion>Conclusion</h1><p>Dans cet exemple pas-à-pas, nous avons construit un logiciel complet.</p><p>À présent vous pouvez poursuivre les tests en changeant les valeurs initiales de $\Theta$ ou en utilisant un autre solver fournit par Gorgonia.</p><p>Le code complet de ce tutoriel est présent dans le répertoire <a href=https://github.com/gorgonia/gorgonia/tree/master/examples>examples</a> des sources de Gorgonia.</p><h3 id=bonus-visual-representation>Bonus: visual representation</h3><p>Il est possible de visualiser le dataset en utilisant la bibliothèque plotter du projet Gonum.
Voici un exemple.</p><p><img src=/images/iris/iris.png alt=iris></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>import</span> (
    <span style=color:#e6db74>&#34;gonum.org/v1/plot&#34;</span>
    <span style=color:#e6db74>&#34;gonum.org/v1/plot/plotter&#34;</span>
    <span style=color:#e6db74>&#34;gonum.org/v1/plot/plotutil&#34;</span>
    <span style=color:#e6db74>&#34;gonum.org/v1/plot/vg&#34;</span>
    <span style=color:#e6db74>&#34;gonum.org/v1/plot/vg/draw&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>plotData</span>(<span style=color:#a6e22e>x</span> []<span style=color:#66d9ef>float64</span>, <span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>float64</span>) []<span style=color:#66d9ef>byte</span> {
	<span style=color:#a6e22e>p</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>plot</span>.<span style=color:#a6e22e>New</span>()
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
	}

	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Title</span>.<span style=color:#a6e22e>Text</span> = <span style=color:#e6db74>&#34;sepal length &amp; width&#34;</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>X</span>.<span style=color:#a6e22e>Label</span>.<span style=color:#a6e22e>Text</span> = <span style=color:#e6db74>&#34;length&#34;</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Y</span>.<span style=color:#a6e22e>Label</span>.<span style=color:#a6e22e>Text</span> = <span style=color:#e6db74>&#34;width&#34;</span>
	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>plotter</span>.<span style=color:#a6e22e>NewGrid</span>())

	<span style=color:#a6e22e>l</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>x</span>) <span style=color:#f92672>/</span> len(<span style=color:#a6e22e>a</span>)
	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>; <span style=color:#a6e22e>k</span> <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>k</span><span style=color:#f92672>++</span> {
		<span style=color:#a6e22e>data0</span> <span style=color:#f92672>:=</span> make(<span style=color:#a6e22e>plotter</span>.<span style=color:#a6e22e>XYs</span>, <span style=color:#ae81ff>0</span>)
		<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>a</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>k</span> <span style=color:#f92672>!=</span> int(<span style=color:#a6e22e>a</span>[<span style=color:#a6e22e>i</span>]) {
				<span style=color:#66d9ef>continue</span>
			}
			<span style=color:#a6e22e>x1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#a6e22e>l</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>] <span style=color:#75715e>// sepal_length
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>y1</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>x</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>*</span><span style=color:#a6e22e>l</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#75715e>// sepal_width
</span><span style=color:#75715e></span>			<span style=color:#a6e22e>data0</span> = append(<span style=color:#a6e22e>data0</span>, <span style=color:#a6e22e>plotter</span>.<span style=color:#a6e22e>XY</span>{<span style=color:#a6e22e>X</span>: <span style=color:#a6e22e>x1</span>, <span style=color:#a6e22e>Y</span>: <span style=color:#a6e22e>y1</span>})
		}
		<span style=color:#a6e22e>data</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>plotter</span>.<span style=color:#a6e22e>NewScatter</span>(<span style=color:#a6e22e>data0</span>)
		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
		}
		<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>GlyphStyle</span>.<span style=color:#a6e22e>Color</span> = <span style=color:#a6e22e>plotutil</span>.<span style=color:#a6e22e>Color</span>(<span style=color:#a6e22e>k</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
		<span style=color:#a6e22e>data</span>.<span style=color:#a6e22e>Shape</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>draw</span>.<span style=color:#a6e22e>PyramidGlyph</span>{}
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>data</span>)
		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Legend</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprint</span>(<span style=color:#a6e22e>k</span>), <span style=color:#a6e22e>data</span>)
	}

	<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>WriterTo</span>(<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span><span style=color:#a6e22e>vg</span>.<span style=color:#a6e22e>Inch</span>, <span style=color:#ae81ff>4</span><span style=color:#f92672>*</span><span style=color:#a6e22e>vg</span>.<span style=color:#a6e22e>Inch</span>, <span style=color:#e6db74>&#34;png&#34;</span>)
	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		panic(<span style=color:#a6e22e>err</span>)
	}
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Buffer</span>
	<span style=color:#a6e22e>writer</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>NewWriter</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>)
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteTo</span>(<span style=color:#a6e22e>writer</span>)
	<span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>WriteFile</span>(<span style=color:#e6db74>&#34;out.png&#34;</span>, <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>(), <span style=color:#ae81ff>0644</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Bytes</span>()
}</code></pre></div><footer class=footline></footer></div></div><div id=navigation><a class="nav nav-prev" href=/fr/tutorials/ title=Tutoriels><i class="fa fa-chevron-left"></i></a><a class="nav nav-next" href=/fr/how-to/ title=How-tos style=margin-right:0><i class="fa fa-chevron-right"></i></a></div></section><div style=left:-1000px;overflow:scroll;position:absolute;top:-1000px;border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px><div style=border:none;box-sizing:content-box;height:200px;margin:0;padding:0;width:200px></div></div><script src=/js/clipboard.min.js?1572884042></script><script src=/js/perfect-scrollbar.min.js?1572884042></script><script src=/js/perfect-scrollbar.jquery.min.js?1572884042></script><script src=/js/jquery.sticky.js?1572884042></script><script src=/js/featherlight.min.js?1572884042></script><script src=/js/highlight.pack.js?1572884042></script><script>hljs.initHighlightingOnLoad();</script><script src=/js/modernizr.custom-3.6.0.js?1572884042></script><script src=/js/learn.js?1572884042></script><script src=/js/hugo-learn.js?1572884042></script><link href=/mermaid/mermaid.css?1572884042 rel=stylesheet><script src=/mermaid/mermaid.js?1572884042></script><script>mermaid.initialize({startOnLoad:true});</script></body></html>