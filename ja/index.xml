<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>main on Gorgonia</title><link>https://gorgonia.org/ja/</link><description>Recent content in main on Gorgonia</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 29 Oct 2019 14:59:59 +0100</lastBuildDate><atom:link href="https://gorgonia.org/ja/index.xml" rel="self" type="application/rss+xml"/><item><title>計算グラフ</title><link>https://gorgonia.org/ja/about/computation-graph/</link><pubDate>Sun, 10 Nov 2019 21:09:19 +0100</pubDate><guid>https://gorgonia.org/ja/about/computation-graph/</guid><description>Gorgonia はグラフベース _Note_：この記事は このブログ投稿 からインスピレーションを得ています。
Tensorflow や Theano など殆どの深層学習ライブラリと同様に、Gorgonia は方程式がグラフで表現できるという概念に依存しています。
方程式グラフをプログラマーが操作できる ExprGraph オブジェクトとして公開します。
ですので以下の様に書く代わりに:
func main() { fmt.Printf(&amp;#34;%v&amp;#34;, 1+1) } プログラマはこう書くのです:
func main() { // Create a graph. g := gorgonia.NewGraph() // Create a node called &amp;#34;x&amp;#34; with the value 1. x := gorgonia.NodeFromAny(g, 1, gorgonia.WithName(&amp;#34;x&amp;#34;)) // Create a node called &amp;#34;y&amp;#34; with the value 1. y := gorgonia.NodeFromAny(g, 1, gorgonia.WithName(&amp;#34;y&amp;#34;)) // z := x + y z := gorgonia.</description></item><item><title>グラフと Exprgraph</title><link>https://gorgonia.org/ja/reference/exprgraph/</link><pubDate>Tue, 29 Oct 2019 19:49:05 +0100</pubDate><guid>https://gorgonia.org/ja/reference/exprgraph/</guid><description>計算グラフまたは式グラフについて多くのことが言われています。しかしそれらは正しいのでしょうか？あなたが望む数学表現の AST と考えてください。上記の例のグラフを次に示します(ただし代わりにベクトルとスカラーを追加します):
ちなみに Gorgonia には素敵なグラフ印刷機能が備わっています。方程式 $y = x^2$ とその派生のグラフの例を次に示します:
グラフを読むのは簡単です。式は下から上に構築され、派生は上から下に構築されます。これにより各ノードの導関数はほぼ同じレベルとなります。
赤枠のノードはそれがルート node であることを示します。緑のアウトラインノードは葉 node であることを示します。背景が黄色のノードは入力ノードであることを示しています。点線の矢印はどのノードがポイント先ノードのグラデーションノードであるかを示しています。
具体的には c42011e840 ($\frac{\partial{y}}{\partial{x}}$) が入力 c42011e000 (つまり $x$) の勾配ノードであると言います。</description></item><item><title>こんにちわ世界</title><link>https://gorgonia.org/ja/tutorials/hello-world/</link><pubDate>Tue, 29 Oct 2019 17:54:31 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/hello-world/</guid><description>これはGorgoniaでとても簡単な計算を行うための段階的なチュートリアルです。
私たちのゴールはGorgoniaのすべての配管を使用して簡単な操作を行うことです:
$ f(x,y) = x + y $
値は x = 2 と y = 5
どの様に動作するか x + y = z の評価はグラフで表す事ができます:
graph LR; z[z] -- add(Round edge) add[+] -- x add[+] -- y 結果を計算する為に4つのステップを使います:
Gorgonia で式の様なグラフを作成する nodes x と y に幾つかの値を設定する gorgonia vm上でグラフを起動する node zからvalueを取り出す * グラフの作成 以下の方法で空の式グラフを作成します:
g := gorgonia.NewGraph() ノードの作成 いくつかのノードを作成しそれらを ExprGraph に関連付けます。
var x, y, z *gorgonia.Node プレースホルダの作成 xとyはスカラー変数です。対応するノードは次のように作成できます:
x = gorgonia.</description></item><item><title>簡単なニューラルネットの構築 (MNIST)</title><link>https://gorgonia.org/ja/tutorials/mnist/</link><pubDate>Tue, 29 Oct 2019 20:09:05 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/mnist/</guid><description>はじめに これは MNIST データセットを使って convocation neural network を段階的に構築し練習する為のチュートリアルです。
完全なコードは、Gorgonia メインリポジトリの examples ディレクトリにあります。 このチュートリアルの目的はコードを詳細に説明することです。 仕組みの詳細については、次の書籍で見ることができます。 Go Machine Learning Projects
データセット このパートではデータセットの読み込みと表示について説明します。ニューラルネットの個所に直接ジャンプしたい場合はスキップして Convolution Neural Net part に進んでください。
学習およびテストセットは次からダウンロードできます。 Yann LeCun&amp;rsquo;s MNIST website
train-images-idx3-ubyte.gz: training set images (9912422 bytes) train-labels-idx1-ubyte.gz: training set labels (28881 bytes) t10k-images-idx3-ubyte.gz: test set images (1648877 bytes) t10k-labels-idx1-ubyte.gz: test set labels (4542 bytes) Every image/label starts with a magic number. The encoding/binary package of the standard library of Go makes it easy to read those files.</description></item><item><title>発表</title><link>https://gorgonia.org/ja/reference/present/</link><pubDate>Mon, 04 Nov 2019 09:38:27 +0100</pubDate><guid>https://gorgonia.org/ja/reference/present/</guid><description> このページにはプレゼンテーション内で使用できる資料が含まれています。
ロゴ Logos logo_g.svg (22 ko) logo_g_square.png (142 ko) logo_horizontal.svg (25 ko) logo_vertical.svg (25 ko)</description></item><item><title>Graphviz (dot) を用いた ExprGraph の描画</title><link>https://gorgonia.org/ja/how-to/dot/</link><pubDate>Sun, 01 Dec 2019 10:14:55 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/dot/</guid><description>Gorgonia の encoding パッケージには、ExprGraph を dot language にマーシャリングする関数が含まれています。
これにより graphviz プログラムを用いてグラフの png または svg バージョンを生成することができます。
簡単な方法:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;gorgonia.org/gorgonia&amp;#34; &amp;#34;gorgonia.org/gorgonia/encoding/dot&amp;#34; ) func main() { g := gorgonia.NewGraph() var x, y *gorgonia.Node // define the expression x = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(&amp;#34;x&amp;#34;)) y = gorgonia.NewScalar(g, gorgonia.Float64, gorgonia.WithName(&amp;#34;y&amp;#34;)) gorgonia.Add(x, y) b, err := dot.Marshal(g) if err != nil { log.Fatal(err) } fmt.Println(string(b)) } このプログラムを実行して出力を dot プロセスに送り込むと画像が生成されます。
例:
$ go run main.</description></item><item><title>Iris データセットでの多変量線形回帰</title><link>https://gorgonia.org/ja/tutorials/iris/</link><pubDate>Thu, 31 Oct 2019 14:53:37 +0100</pubDate><guid>https://gorgonia.org/ja/tutorials/iris/</guid><description>はじめに Gorgoniaを使用して線形回帰モデルを作成します。
ゴールは以下に与えられた特性を考慮して花の種別を予測することです:
sepal_length sepal_width petal_length petal_width 存在する種別は以下の通り:
setosa virginica versicolor このチュートリアルのゴールはgorgoniaを使用して、与えられたirisデータセットから $\Theta$ の正しい値を見つけ以下のようなcliユーティリティを作成することです:
./iris sepal length: 5 sepal width: 3.5 petal length: 1.4 sepal length: 0.2 It is probably a setosa このチュートリアルは学術目的の為の物です。Gorgoniaでこれをどの様にして行うかを説明することがゴールです; これは特定の問題に対する最先端の答えではありません。
数学的表現 良くある花弁の長さと幅だけでなく、がく片の長さと幅の関数であった場合とその種別について考察します。
したがって $y$ が種別の値であると考える場合に解決すべき方程式は次の通りです:
$$ y = \theta_0 + \theta_1 * sepal\_length + \theta_2 * sepal\_width + \theta_3 * petal\_length + \theta_4 * petal\_width$$
ベクトルを考慮した場合の $x$ と $\Theta$ はこうなります:</description></item><item><title>データフレームからテンソルを作成 (gota)</title><link>https://gorgonia.org/ja/how-to/dataframe/</link><pubDate>Wed, 30 Oct 2019 22:57:09 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/dataframe/</guid><description>このハウツーでは、gotaを使用してデータフレームからテンソルを作成する方法を説明します。 The goal is to read a csv file and create a *tensor.Dense with shape (2,2). ゴールは、csvファイルを読み取り、(2,2) のシェイプの* tensor.Denseを作成することです。
csvファイルからデータフレームを作成する 以下のコンテンツのcsvファイルを考えます:
sepal_length,sepal_width,petal_length,petal_width,species 5.1 ,3.5 ,1.4 ,0.2 ,setosa 4.9 ,3.0 ,1.4 ,0.2 ,setosa 4.7 ,3.2 ,1.3 ,0.2 ,setosa 4.6 ,3.1 ,1.5 ,0.2 ,setosa 5.0 ,3.6 ,1.4 ,0.2 ,setosa ... これはIris flower data setからの抜粋です。 データセットのコピーはここから見つける事ができます。
種別以外のすべての値を含むテンソルを作成します。
gotaを使用してデータフレームを作成する gotaのデータフレームパッケージにはio.Readerを引数として取る関数ReadCSVがあります。
f, err := os.Open(&amp;#34;iris.csv&amp;#34;) if err != nil { log.Fatal(err) } defer f.</description></item><item><title>Weightsの保存</title><link>https://gorgonia.org/ja/how-to/save-weights/</link><pubDate>Tue, 29 Oct 2019 20:07:16 +0100</pubDate><guid>https://gorgonia.org/ja/how-to/save-weights/</guid><description>ゴール このハウツーのゴールはノードの値を保存して復元する方法を説明することです。
実装 現状できる最善の方法は、対応するノードの値を保存して復元することです。
テンソルはGobEncodeおよびGobDecodeインターフェースを実現しており、これが最良のオプションです。 バックエンドを要素のスライスとして保存することもできますがこれは少し複雑です。
これを行うサンプルコードを以下に示します(まったく最適化していません。自由に修正してください):
package main import ( &amp;#34;encoding/gob&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; &amp;#34;gorgonia.org/gorgonia&amp;#34; &amp;#34;gorgonia.org/tensor&amp;#34; ) var ( backup = &amp;#34;/tmp/example_gorgonia&amp;#34; ) func main() { g := gorgonia.NewGraph() var x, y, z *gorgonia.Node var err error // Create the graph x = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(&amp;#34;x&amp;#34;)) y = gorgonia.NewTensor(g, gorgonia.Float64, 2, gorgonia.WithShape(2, 2), gorgonia.WithName(&amp;#34;y&amp;#34;)) if z, err = gorgonia.Add(x, y); err != nil { log.</description></item><item><title>LispMachine</title><link>https://gorgonia.org/ja/reference/vm/lispmachine/</link><pubDate>Tue, 29 Oct 2019 19:50:15 +0100</pubDate><guid>https://gorgonia.org/ja/reference/vm/lispmachine/</guid><description>LispMachine はグラフを入力として受け取るように設計されており、グラフのノードで直接実行されます。 グラフが変更された場合は、単純に新しい軽量 LispMachine を作成して実行します。 LispMachine はサイズが固定されていない recurrent neural networks の作成などのタスクに適しています。
トレードオフとしては LispMachine でのグラフの実行が TapeMachine での実行よりも一般に遅いことです。 グラフの同じ静的な &amp;ldquo;画像&amp;rdquo; が与えられます。</description></item><item><title>Tapemachine</title><link>https://gorgonia.org/ja/reference/vm/tapemachine/</link><pubDate>Tue, 29 Oct 2019 19:50:15 +0100</pubDate><guid>https://gorgonia.org/ja/reference/vm/tapemachine/</guid><description>TapeMachine は一般的にに静的な式を実行するのに役立ちます(つまり計算グラフは変更されない)。 静的な性質があるので TapeMachine は一度だけコンパイルされ何度も式を実行するのに向いています(線形回帰や SVM など)。
技術詳細 TapeMachine はインストラクションのリストに対してグラフを事前コンパイルします。 その後、命令を線形に順次実行します。 主なトレードオフはダイナミズムです。 再コンパイルプロセスが必要になるため、グラフを動的に作成することはできません(コンパイルは比較的高価なため)。 ただし、コード生成段階で多くの最適化が行われるため TapeMachine で実行されるグラフははるかに高速に実行されます。</description></item><item><title>数式微分</title><link>https://gorgonia.org/ja/about/differentiation/symbolicdiff/</link><pubDate>Tue, 29 Oct 2019 19:49:25 +0100</pubDate><guid>https://gorgonia.org/ja/about/differentiation/symbolicdiff/</guid><description>このページは数式微分の仕組みについて説明します</description></item><item><title>自動微分</title><link>https://gorgonia.org/ja/about/differentiation/autodiff/</link><pubDate>Tue, 29 Oct 2019 19:49:25 +0100</pubDate><guid>https://gorgonia.org/ja/about/differentiation/autodiff/</guid><description>このページは自動微分の仕組みについて説明します</description></item></channel></rss>